x=c("L","I","J","A","G","C")

####################################################################################################################################
## load the data
gdp.all <- read.csv("http://astro.temple.edu/~zhaozhg/Stat8003/data/GDP_Per_Capita.csv")

gdp <- gdp.all[,62]
gdp[ is.na(gdp) ] <- NULL

####################################################################################################################################
####################################################################################################################################
####################################################################################################################################
####################################################################################################################################
####################################################################################################################################
####################################################################################################################################
## Example: traffic light
traffic.light <- read.csv("http://astro.temple.edu/~zhaozhg/Stat8003/data/traffic_light.txt")
apply( traffic.light, 1, prod )
m1 <- sum( traffic.light$n * traffic.light$freq )/sum( traffic.light$freq )
lambda.hat1 <- m1
## Calculate MOM based on the variance
## ## create a new column x_i-bar{x}
traffic.light$diff <- (traffic.light$n)^2
m2 <- sum(  traffic.light$freq * traffic.light$diff )/ ( sum( traffic.light$freq ) )
lambda.hat2 <- ( sqrt( 1+4*m2) -1 )/2



####################################################################################################################################
####################################################################################################################################
####################################################################################################################################
####################################################################################################################################
####################################################################################################################################
####################################################################################################################################

## Plot the density function and the likelihood function of N(\theta, 1)
##              theta=1
##              X=1
x <- c(1:1000)/100
postscript( file="./figure/density.eps",horizontal=FALSE)
plot(x, dexp( x, 1), 'l', col='red', xlab="x", ylab="density", main="pdf", cex.lab=1.5, cex.main=2)
dev.off()

lambda.all <- c(1:1000)/100
postscript( file="./figure/likelihood.eps",horizontal=FALSE)
plot(lambda.all, dexp( 1, lambda.all), 'l', col='red', xlab="lambda", ylab="likelihood", main="Likelihood", cex.lab=1.5, cex.main=2)
dev.off()


####################################################################################################################################
####################################################################################################################################
####################################################################################################################################
####################################################################################################################################
####################################################################################################################################
####################################################################################################################################
## Space shuttle
shuttle <- read.csv("http://astro.temple.edu/~zhaozhg/Stat8003/data/shuttle.txt")
mean( shuttle$ndo /2 )



####################################################################################################################################
####################################################################################################################################
####################################################################################################################################
####################################################################################################################################
####################################################################################################################################
####################################################################################################################################
## Newton Raphson algorithm for the solve the inverse of trigamma function.

gdp.all <- read.csv("http://astro.temple.edu/~zhaozhg/Stat8003/data/GDP_Per_Capita.csv")
gdp <- gdp.all[,62]
gdp[ is.na(gdp) ] <- NULL
l.gdp <- log(gdp)
l.m2 <- mean( l.gdp^2 )
l.m1 <- mean( l.gdp )
v.gdp <- l.m2-l.m1^2

## Initial value
alpha.old <- 2
alpha.new <- 2
delta <- 0.0001
Delta <- 1
itr <- 1

while(Delta > delta )
  {
    alpha.old <- alpha.new
    alpha.new <- alpha.old - ( psigamma( alpha.old, 1) - v.gdp )/ psigamma( alpha.old, 2 )
    Delta <- abs(alpha.new-alpha.old)
    print( paste("Iter:", itr,":", alpha.new, sep=" ") )
    itr <- itr+1
  }

l.alpha.mom <- alpha.new
l.beta.mom <- exp( l.m1 - psigamma( l.alpha.mom, 0 ) )

trigammaInverse( v.gdp )




####################################################################################################################################
####################################################################################################################################
####################################################################################################################################
####################################################################################################################################
####################################################################################################################################
####################################################################################################################################
## Newton Raphson algorithm for the solve MLE of gamma model.

gdp.all <- read.csv("http://astro.temple.edu/~zhaozhg/Stat8003/data/GDP_Per_Capita.csv")
gdp <- gdp.all[,62]
gdp[ is.na(gdp) ] <- NULL
l.gdp <- log(gdp)
m1 <- mean( gdp )
l.m1 <- mean( l.gdp )
m2 <- mean( gdp^2 )


## Initial value
## Choose the initial value according to the MOM estimator
beta.mom <- (m2-m1^2)/m1
alpha.mom <- m1/beta.mom

theta.old <- matrix( c(alpha.mom,beta.mom), 2, 1 ) ## This is a vector for alpha and beta
theta.new <- theta.old
delta <- 0.0001
Delta <- 1
itr <- 1

while(Delta > delta )
  {
    theta.old <- theta.new
    Jacobian <- matrix( c( -psigamma( theta.old[1], 1), -theta.old[2], -1/theta.old[2], -theta.old[1] ), 2, 2) ### Calculate the Jacobian matrix
    f.value <- matrix( c( l.m1 - psigamma( theta.old[1], 0)- log( theta.old[2]), m1 - theta.old[1] * theta.old[2] ), 2, 1) ### calculate the value of the f function
    theta.new <- theta.old - solve( Jacobian ) %*% f.value ### Newton raphson updates
    Delta <- sum( (theta.new-theta.old)^2 )
    print( paste("Iter:", itr,", alpha= ", theta.new[1], ",beta=", theta.new[2] , sep=" ") )
    itr <- itr+1
  }
alpha.mle <- theta.new[1]
beta.mle <- theta.new[2]
